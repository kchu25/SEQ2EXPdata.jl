var documenterSearchIndex = {"docs":
[{"location":"#SEQ2EXPdata","page":"Home","title":"SEQ2EXPdata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SEQ2EXPdata is a Julia package for organizing biological sequence data and their associated expression labels. It is suitable for DNA, RNA, or protein sequence datasets, and helps keep your data consistent and analysis-ready.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main component of this package is the SEQ2EXP_Dataset type, which stores:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Biological sequences as strings\nCorresponding expression labels (single values or multiple features per sequence)\nOptional feature names for multi-dimensional labels","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SEQ2EXPdata\n\n# Simple dataset with one label per sequence\nds = SEQ2EXP_Dataset([\"ATCG\", \"GGTA\"], [1.2, 3.4])\n\n# Dataset with multiple features and names\n# Note that the second dimension of the labels must always match the number of strings.\nds2 = SEQ2EXP_Dataset(\n    [\"ATCG\", \"GGTA\"],\n    [1.2 2.3; 3.4 4.5],\n    feature_names=[\"exp1\", \"exp2\"]\n)","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#SEQ2EXPdata.SEQ2EXPdata","page":"Home","title":"SEQ2EXPdata.SEQ2EXPdata","text":"SEQ2EXPdata\n\nA Julia package for handling biological sequence data and corresponding expression labels.\n\nProvides the SEQ2EXP_Dataset type and utility functions for validation and manipulation of sequence-expression datasets.\n\n\n\n\n\n","category":"module"},{"location":"#SEQ2EXPdata.OnehotSEQ2EXP_Dataset","page":"Home","title":"SEQ2EXPdata.OnehotSEQ2EXP_Dataset","text":"OnehotSEQ2EXP_Dataset{T}(raw_data::SEQ2EXP_Dataset{T})\n\nA container for a sequence-expression dataset and its one-hot encoded representation.\n\nFields\n\nraw_data::SEQ2EXP_Dataset{T}: The original dataset with sequences and labels.\nonehot_sequences::AbstractArray{T, 4}: The one-hot encoded tensor of the sequences (channels × length × 1 × N).\n\nExample\n\nseqs = [\"ATCG\", \"GGTA\"]\nlabels = [1.0, 2.0]\nds = SEQ2EXP_Dataset(seqs, labels)\nods = OnehotSEQ2EXP_Dataset(ds)\n\n\n\n\n\n","category":"type"},{"location":"#SEQ2EXPdata.SEQ2EXP_Dataset","page":"Home","title":"SEQ2EXPdata.SEQ2EXP_Dataset","text":"SEQ2EXP_Dataset{T<:Real}(strings, labels; feature_names=nothing)\n\nA container for biological sequence data and corresponding expression labels.\n\nArguments\n\nstrings::Vector{String}: Vector of biological sequences (all must be the same length).\nlabels::Union{Vector{T}, Matrix{T}}: Expression labels for each sequence. Can be a vector (single label per sequence) or a matrix (multiple labels per sequence).\nfeature_names::Union{Vector{String}, Nothing}: Optional names for each feature (column) in labels.\n\nExamples\n\nds = SEQ2EXP_Dataset([\"ATCG\", \"GGTA\"], [1.2, 3.4])\nds2 = SEQ2EXP_Dataset([\"ATCG\", \"GGTA\"], [1.2 2.3; 3.4 4.5], feature_names=[\"exp1\", \"exp2\"])\n\n\n\n\n\n","category":"type"},{"location":"#Base.getproperty-Tuple{OnehotSEQ2EXP_Dataset, Symbol}","page":"Home","title":"Base.getproperty","text":"Base.getproperty(dataset::OnehotSEQ2EXP_Dataset, sym::Symbol)\n\nAllow dot-access to X and Y as virtual fields for a OnehotSEQ2EXP_Dataset.\n\nods.X returns the one-hot encoded tensor (same as ods.onehot_sequences).\nods.Y returns the label array (same as ods.raw_data.labels).\nAll other fields are accessed as usual.\n\nThis enables convenient and familiar ML-style access to features and labels without storing redundant fields.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, OnehotSEQ2EXP_Dataset}","page":"Home","title":"Base.show","text":"Base.show(io::IO, dataset::OnehotSEQ2EXP_Dataset)\n\nCustom display for OnehotSEQ2EXP_Dataset.\n\nPrints the number and length of sequences, the shape of the one-hot tensor, label information, and feature names if available.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_consensus-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.get_consensus","text":"get_consensus(ds::SEQ2EXP_Dataset) -> String\n\nGet the consensus sequence from the dataset. Throws an error if no consensus exists.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_consensus-Tuple{Vector{String}}","page":"Home","title":"SEQ2EXPdata.get_consensus","text":"get_consensus(strings::Vector{String}) -> String\n\nCompute the consensus sequence from a vector of strings of equal length.\n\nFor each position, finds the most frequently occurring character and constructs the consensus sequence using these most common characters.\n\nArguments\n\nstrings::Vector{String}: Vector of strings, all must be the same length\n\nReturns\n\nString: Consensus sequence\n\nExamples\n\nstrings = [\"ATCG\", \"ACCG\", \"ATCA\"]\nconsensus = get_consensus(strings)\n# Returns \"ATCG\" (A-T-C-G are most frequent at positions 1-2-3-4)\n\nNote: \n\nIf multiple characters are equally frequent at a position, it will arbitrarily choose one.\nMake sure to run check_all_strings_same_length before using this function    to ensure all strings are of equal length.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_feature_counts-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.get_feature_counts","text":"get_feature_counts(dataset::SEQ2EXP_Dataset) -> Int\n\nReturn the number of features (columns) in the labels array.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_feature_names-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.get_feature_names","text":"get_feature_names(dataset::SEQ2EXP_Dataset) -> Union{Vector{String}, Nothing}\n\nGet the feature names from the dataset, or nothing if not provided.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_sequence_and_labels-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.get_sequence_and_labels","text":"get_sequence_and_labels(dataset::SEQ2EXP_Dataset) -> (Vector{String}, Union{Vector, Matrix})\n\nReturn the sequences and labels as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.get_sequence_length-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.get_sequence_length","text":"get_sequence_length(strings::Vector{String}) -> Int\n\nGet the length of the sequences in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.has_consensus-Tuple{SEQ2EXP_Dataset}","page":"Home","title":"SEQ2EXPdata.has_consensus","text":"has_consensus(ds::SEQ2EXP_Dataset) -> Bool\n\nCheck if the dataset has a consensus sequence.\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.infer_sequence_type-Tuple{AbstractVector{String}}","page":"Home","title":"SEQ2EXPdata.infer_sequence_type","text":"infer_sequence_type(sequences::AbstractVector{String})\n\nAutomatically infer whether sequences are nucleotides or amino acids based on their character content.\n\nArguments\n\nsequences::AbstractVector{String}: Vector of biological sequences\n\nReturns\n\nType{Nucleotide}: If sequences contain only nucleotide characters (A, C, G, T, U, N)\nType{AminoAcid}: If sequences contain amino acid characters beyond nucleotides\nnothing: If sequences contain characters not found in standard biological alphabets\n\nExamples\n\ndna_seqs = [\"ATCG\", \"GCTA\", \"TTAA\"]\ninfer_sequence_type(dna_seqs)  # Returns Nucleotide\n\nprotein_seqs = [\"ACDE\", \"FGHI\", \"KLMN\"]  \ninfer_sequence_type(protein_seqs)  # Returns AminoAcid\n\nmixed_seqs = [\"ATCGX\", \"INVALID\"]\ninfer_sequence_type(mixed_seqs)  # Returns nothing\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.longest_common_prefix-Tuple{Any}","page":"Home","title":"SEQ2EXPdata.longest_common_prefix","text":"longest_common_prefix(sequences)\n\nFind the longest common prefix shared by all sequences in the input array.\n\nArguments\n\nsequences: An array of sequences (strings, arrays, or any indexable collections)\n\nReturns\n\nThe longest common prefix as the same type as the input sequences\nIf no common prefix exists, returns an empty sequence of the same type\n\nExamples\n\nlongest_common_prefix([\"hello\", \"help\", \"helicopter\"])  # returns \"hel\"\nlongest_common_prefix([\"abc\", \"def\"])                   # returns \"\"\nlongest_common_prefix([[1,2,3,4], [1,2,5,6]])         # returns [1,2]\n\nNotes\n\nThe length of the returned prefix can be used as an \"offset\" to skip the common  beginning when processing the sequences\nRequires at least one sequence in the input array\nAll sequences are compared character-by-character (or element-by-element)\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.longest_common_suffix-Tuple{Any}","page":"Home","title":"SEQ2EXPdata.longest_common_suffix","text":"longest_common_suffix(sequences)\n\nFind the longest common suffix shared by all sequences in the input array.\n\nArguments\n\nsequences: An array of sequences (strings, arrays, or any indexable collections)\n\nReturns\n\nThe longest common suffix as the same type as the input sequences\nIf no common suffix exists, returns an empty sequence of the same type\n\nExamples\n\nlongest_common_suffix([\"testing\", \"running\", \"jumping\"])  # returns \"ing\"\nlongest_common_suffix([\"abc\", \"def\"])                     # returns \"\"\nlongest_common_suffix([[1,2,3,4], [5,6,3,4]])           # returns [3,4]\n\nNotes\n\nImplemented by reversing all sequences, finding the common prefix of the reversed  sequences, then reversing the result\nThe length of the returned suffix indicates how many characters/elements to  trim from the end of each sequence\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.sequences_to_tensor_auto-Tuple{AbstractVector{String}}","page":"Home","title":"SEQ2EXPdata.sequences_to_tensor_auto","text":"sequences_to_tensor_auto(sequences::AbstractVector{String}; T=Float32)\n\nAutomatically infer sequence type and convert to tensor.\n\nArguments\n\nsequences::AbstractVector{String}: Vector of biological sequences\nT: Element type for the output tensor (default: Float32)\n\nReturns\n\nArray{T,4}: Encoded tensor with automatically inferred sequence type\nThrows ArgumentError if sequence type cannot be determined\n\nExamples\n\n# Automatically detects DNA and encodes as nucleotides\ndna_seqs = [\"ATCG\", \"GCTA\", \"TTAA\"]\ndna_tensor = sequences_to_tensor_auto(dna_seqs)  # 4 x 4 x 1 x 3 tensor\n\n# Automatically detects protein and encodes as amino acids\nprotein_seqs = [\"ACDEFGHI\", \"KLMNPQRS\"]  \nprotein_tensor = sequences_to_tensor_auto(protein_seqs)  # 20 x 8 x 1 x 2 tensor\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.trim_common_ends-Tuple{Vector{String}}","page":"Home","title":"SEQ2EXPdata.trim_common_ends","text":"trim_common_ends(sequences) -> (prefix_offset, trimmed_sequences)\n\nRemove the longest common prefix and suffix from all sequences, returning the  prefix offset and the unique middle portions.\n\nArguments\n\nsequences: An array of sequences (strings, arrays, or any indexable collections)\n\nReturns\n\nprefix_offset: Integer indicating the length of the common prefix (offset to unique content)\ntrimmed_sequences: An array of sequences with common prefix and suffix removed\nEach trimmed sequence contains only the portion that differs between sequences\nIf sequences become empty after trimming, returns empty sequences\n\nExamples\n\ntrim_common_ends([\"prefix_A_suffix\", \"prefix_B_suffix\"])  \n# returns (7, [\"_A_\", \"_B_\"])\n\ntrim_common_ends([\"hello\", \"help\", \"helicopter\"])         \n# returns (3, [\"lo\", \"p\", \"icopter\"])\n\ntrim_common_ends([[1,2,3,4,5], [1,2,9,4,5]])           \n# returns (2, [[3], [9]])\n\nNotes\n\nCombines longest_common_prefix and longest_common_suffix to isolate the  unique portions of each sequence\nUseful for finding the \"core differences\" between similar sequences\nThe prefix offset indicates where the unique content begins in the original sequences\nThe suffix length indicates how many elements were excluded from the end\nUse the prefix offset to map positions in trimmed sequences back to original sequences\n\n\n\n\n\n","category":"method"},{"location":"#SEQ2EXPdata.@seq2exp-Tuple{Any, Any, Vararg{Any}}","page":"Home","title":"SEQ2EXPdata.@seq2exp","text":"@seq2exp sequences labels [feature_names] [GET_CONSENSUS=false]\n\nA convenient macro for creating SEQ2EXP_Dataset instances with cleaner syntax.\n\nArguments\n\nsequences: Vector of biological sequences\nlabels: Vector or Matrix of expression values  \nfeature_names (optional): Vector of feature names\nGET_CONSENSUS (optional): Boolean flag to compute consensus sequence\n\nExamples\n\n# Simple case\nds1 = @seq2exp [\"ATCG\", \"GGTA\"] [1.2, 3.4]\n\n# With feature names\nds2 = @seq2exp [\"ATCG\", \"GGTA\"] [1.2 2.3; 3.4 4.5] [\"exp1\", \"exp2\"]\n\n# With consensus computation\nds3 = @seq2exp [\"ATCG\", \"ATCA\"] [1.0, 2.0] nothing GET_CONSENSUS=true\n\n\n\n\n\n","category":"macro"}]
}
